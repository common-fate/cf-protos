// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: certrail/v1alpha1/certrail.proto

package certrailv1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ApproveConfigPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApproveConfigPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApproveConfigPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApproveConfigPayloadMultiError, or nil if none found.
func (m *ApproveConfigPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *ApproveConfigPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetConfigSha256()) != 32 {
		err := ApproveConfigPayloadValidationError{
			field:  "ConfigSha256",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ApprovedBy

	if len(errors) > 0 {
		return ApproveConfigPayloadMultiError(errors)
	}

	return nil
}

// ApproveConfigPayloadMultiError is an error wrapping multiple validation
// errors returned by ApproveConfigPayload.ValidateAll() if the designated
// constraints aren't met.
type ApproveConfigPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveConfigPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveConfigPayloadMultiError) AllErrors() []error { return m }

// ApproveConfigPayloadValidationError is the validation error returned by
// ApproveConfigPayload.Validate if the designated constraints aren't met.
type ApproveConfigPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveConfigPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveConfigPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveConfigPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveConfigPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveConfigPayloadValidationError) ErrorName() string {
	return "ApproveConfigPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveConfigPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveConfigPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveConfigPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveConfigPayloadValidationError{}

// Validate checks the field values on GetEntryIndexByMerkleHashRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetEntryIndexByMerkleHashRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEntryIndexByMerkleHashRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetEntryIndexByMerkleHashRequestMultiError, or nil if none found.
func (m *GetEntryIndexByMerkleHashRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEntryIndexByMerkleHashRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MerkleHash

	if len(errors) > 0 {
		return GetEntryIndexByMerkleHashRequestMultiError(errors)
	}

	return nil
}

// GetEntryIndexByMerkleHashRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetEntryIndexByMerkleHashRequest.ValidateAll() if the designated
// constraints aren't met.
type GetEntryIndexByMerkleHashRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEntryIndexByMerkleHashRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEntryIndexByMerkleHashRequestMultiError) AllErrors() []error { return m }

// GetEntryIndexByMerkleHashRequestValidationError is the validation error
// returned by GetEntryIndexByMerkleHashRequest.Validate if the designated
// constraints aren't met.
type GetEntryIndexByMerkleHashRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEntryIndexByMerkleHashRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEntryIndexByMerkleHashRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEntryIndexByMerkleHashRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEntryIndexByMerkleHashRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEntryIndexByMerkleHashRequestValidationError) ErrorName() string {
	return "GetEntryIndexByMerkleHashRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetEntryIndexByMerkleHashRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEntryIndexByMerkleHashRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEntryIndexByMerkleHashRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEntryIndexByMerkleHashRequestValidationError{}

// Validate checks the field values on GetEntryIndexByMerkleHashResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetEntryIndexByMerkleHashResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEntryIndexByMerkleHashResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetEntryIndexByMerkleHashResponseMultiError, or nil if none found.
func (m *GetEntryIndexByMerkleHashResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEntryIndexByMerkleHashResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	if len(errors) > 0 {
		return GetEntryIndexByMerkleHashResponseMultiError(errors)
	}

	return nil
}

// GetEntryIndexByMerkleHashResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetEntryIndexByMerkleHashResponse.ValidateAll() if the designated
// constraints aren't met.
type GetEntryIndexByMerkleHashResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEntryIndexByMerkleHashResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEntryIndexByMerkleHashResponseMultiError) AllErrors() []error { return m }

// GetEntryIndexByMerkleHashResponseValidationError is the validation error
// returned by GetEntryIndexByMerkleHashResponse.Validate if the designated
// constraints aren't met.
type GetEntryIndexByMerkleHashResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEntryIndexByMerkleHashResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEntryIndexByMerkleHashResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEntryIndexByMerkleHashResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEntryIndexByMerkleHashResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEntryIndexByMerkleHashResponseValidationError) ErrorName() string {
	return "GetEntryIndexByMerkleHashResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetEntryIndexByMerkleHashResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEntryIndexByMerkleHashResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEntryIndexByMerkleHashResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEntryIndexByMerkleHashResponseValidationError{}

// Validate checks the field values on RoleAccessRequestPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RoleAccessRequestPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleAccessRequestPayload with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RoleAccessRequestPayloadMultiError, or nil if none found.
func (m *RoleAccessRequestPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleAccessRequestPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Role

	// no validation rules for Provider

	if m.GetAccount() != "" {

		if utf8.RuneCountInString(m.GetAccount()) != 12 {
			err := RoleAccessRequestPayloadValidationError{
				field:  "Account",
				reason: "value length must be 12 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)

		}

	}

	if all {
		switch v := interface{}(m.GetSessionDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleAccessRequestPayloadValidationError{
					field:  "SessionDuration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleAccessRequestPayloadValidationError{
					field:  "SessionDuration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSessionDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleAccessRequestPayloadValidationError{
				field:  "SessionDuration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Group

	// no validation rules for Reason

	// no validation rules for RequestedBy

	// no validation rules for TokenContext

	if len(errors) > 0 {
		return RoleAccessRequestPayloadMultiError(errors)
	}

	return nil
}

// RoleAccessRequestPayloadMultiError is an error wrapping multiple validation
// errors returned by RoleAccessRequestPayload.ValidateAll() if the designated
// constraints aren't met.
type RoleAccessRequestPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleAccessRequestPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleAccessRequestPayloadMultiError) AllErrors() []error { return m }

// RoleAccessRequestPayloadValidationError is the validation error returned by
// RoleAccessRequestPayload.Validate if the designated constraints aren't met.
type RoleAccessRequestPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleAccessRequestPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleAccessRequestPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleAccessRequestPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleAccessRequestPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleAccessRequestPayloadValidationError) ErrorName() string {
	return "RoleAccessRequestPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e RoleAccessRequestPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleAccessRequestPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleAccessRequestPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleAccessRequestPayloadValidationError{}

// Validate checks the field values on ApprovedRoleAccessRequestPayload with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ApprovedRoleAccessRequestPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApprovedRoleAccessRequestPayload with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ApprovedRoleAccessRequestPayloadMultiError, or nil if none found.
func (m *ApprovedRoleAccessRequestPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *ApprovedRoleAccessRequestPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoleAccessRequestTrillianMerkleHash

	// no validation rules for ApprovedBy

	switch m.ProvisionStrategy.(type) {

	case *ApprovedRoleAccessRequestPayload_Window:

		if all {
			switch v := interface{}(m.GetWindow()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApprovedRoleAccessRequestPayloadValidationError{
						field:  "Window",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApprovedRoleAccessRequestPayloadValidationError{
						field:  "Window",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWindow()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApprovedRoleAccessRequestPayloadValidationError{
					field:  "Window",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApprovedRoleAccessRequestPayload_Expires:

		if all {
			switch v := interface{}(m.GetExpires()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApprovedRoleAccessRequestPayloadValidationError{
						field:  "Expires",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApprovedRoleAccessRequestPayloadValidationError{
						field:  "Expires",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExpires()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApprovedRoleAccessRequestPayloadValidationError{
					field:  "Expires",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ApprovedRoleAccessRequestPayloadMultiError(errors)
	}

	return nil
}

// ApprovedRoleAccessRequestPayloadMultiError is an error wrapping multiple
// validation errors returned by
// ApprovedRoleAccessRequestPayload.ValidateAll() if the designated
// constraints aren't met.
type ApprovedRoleAccessRequestPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApprovedRoleAccessRequestPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApprovedRoleAccessRequestPayloadMultiError) AllErrors() []error { return m }

// ApprovedRoleAccessRequestPayloadValidationError is the validation error
// returned by ApprovedRoleAccessRequestPayload.Validate if the designated
// constraints aren't met.
type ApprovedRoleAccessRequestPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApprovedRoleAccessRequestPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApprovedRoleAccessRequestPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApprovedRoleAccessRequestPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApprovedRoleAccessRequestPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApprovedRoleAccessRequestPayloadValidationError) ErrorName() string {
	return "ApprovedRoleAccessRequestPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e ApprovedRoleAccessRequestPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApprovedRoleAccessRequestPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApprovedRoleAccessRequestPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApprovedRoleAccessRequestPayloadValidationError{}

// Validate checks the field values on Window with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Window) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Window with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in WindowMultiError, or nil if none found.
func (m *Window) ValidateAll() error {
	return m.validate(true)
}

func (m *Window) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WindowValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WindowValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WindowValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WindowValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WindowValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WindowValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WindowMultiError(errors)
	}

	return nil
}

// WindowMultiError is an error wrapping multiple validation errors returned by
// Window.ValidateAll() if the designated constraints aren't met.
type WindowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WindowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WindowMultiError) AllErrors() []error { return m }

// WindowValidationError is the validation error returned by Window.Validate if
// the designated constraints aren't met.
type WindowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WindowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WindowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WindowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WindowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WindowValidationError) ErrorName() string { return "WindowValidationError" }

// Error satisfies the builtin error interface
func (e WindowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWindow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WindowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WindowValidationError{}

// Validate checks the field values on Expires with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Expires) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Expires with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExpiresMultiError, or nil if none found.
func (m *Expires) ValidateAll() error {
	return m.validate(true)
}

func (m *Expires) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpiresValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpiresValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpiresValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetApprovedSessionDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpiresValidationError{
					field:  "ApprovedSessionDuration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpiresValidationError{
					field:  "ApprovedSessionDuration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApprovedSessionDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpiresValidationError{
				field:  "ApprovedSessionDuration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExpiresMultiError(errors)
	}

	return nil
}

// ExpiresMultiError is an error wrapping multiple validation errors returned
// by Expires.ValidateAll() if the designated constraints aren't met.
type ExpiresMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpiresMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpiresMultiError) AllErrors() []error { return m }

// ExpiresValidationError is the validation error returned by Expires.Validate
// if the designated constraints aren't met.
type ExpiresValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpiresValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpiresValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpiresValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpiresValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpiresValidationError) ErrorName() string { return "ExpiresValidationError" }

// Error satisfies the builtin error interface
func (e ExpiresValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpires.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpiresValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpiresValidationError{}

// Validate checks the field values on DeclinedRoleAccessRequestPayload with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeclinedRoleAccessRequestPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeclinedRoleAccessRequestPayload with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeclinedRoleAccessRequestPayloadMultiError, or nil if none found.
func (m *DeclinedRoleAccessRequestPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *DeclinedRoleAccessRequestPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoleAccessRequestTrillianMerkleHash

	// no validation rules for DeclinedBy

	if len(errors) > 0 {
		return DeclinedRoleAccessRequestPayloadMultiError(errors)
	}

	return nil
}

// DeclinedRoleAccessRequestPayloadMultiError is an error wrapping multiple
// validation errors returned by
// DeclinedRoleAccessRequestPayload.ValidateAll() if the designated
// constraints aren't met.
type DeclinedRoleAccessRequestPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeclinedRoleAccessRequestPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeclinedRoleAccessRequestPayloadMultiError) AllErrors() []error { return m }

// DeclinedRoleAccessRequestPayloadValidationError is the validation error
// returned by DeclinedRoleAccessRequestPayload.Validate if the designated
// constraints aren't met.
type DeclinedRoleAccessRequestPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeclinedRoleAccessRequestPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeclinedRoleAccessRequestPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeclinedRoleAccessRequestPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeclinedRoleAccessRequestPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeclinedRoleAccessRequestPayloadValidationError) ErrorName() string {
	return "DeclinedRoleAccessRequestPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e DeclinedRoleAccessRequestPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeclinedRoleAccessRequestPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeclinedRoleAccessRequestPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeclinedRoleAccessRequestPayloadValidationError{}

// Validate checks the field values on CancelledRoleAccessRequestPayload with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CancelledRoleAccessRequestPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelledRoleAccessRequestPayload
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CancelledRoleAccessRequestPayloadMultiError, or nil if none found.
func (m *CancelledRoleAccessRequestPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelledRoleAccessRequestPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoleAccessRequestTrillianMerkleHash

	// no validation rules for CancelledBy

	if len(errors) > 0 {
		return CancelledRoleAccessRequestPayloadMultiError(errors)
	}

	return nil
}

// CancelledRoleAccessRequestPayloadMultiError is an error wrapping multiple
// validation errors returned by
// CancelledRoleAccessRequestPayload.ValidateAll() if the designated
// constraints aren't met.
type CancelledRoleAccessRequestPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelledRoleAccessRequestPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelledRoleAccessRequestPayloadMultiError) AllErrors() []error { return m }

// CancelledRoleAccessRequestPayloadValidationError is the validation error
// returned by CancelledRoleAccessRequestPayload.Validate if the designated
// constraints aren't met.
type CancelledRoleAccessRequestPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelledRoleAccessRequestPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelledRoleAccessRequestPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelledRoleAccessRequestPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelledRoleAccessRequestPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelledRoleAccessRequestPayloadValidationError) ErrorName() string {
	return "CancelledRoleAccessRequestPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e CancelledRoleAccessRequestPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelledRoleAccessRequestPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelledRoleAccessRequestPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelledRoleAccessRequestPayloadValidationError{}

// Validate checks the field values on IssueCertificatePayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueCertificatePayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueCertificatePayload with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueCertificatePayloadMultiError, or nil if none found.
func (m *IssueCertificatePayload) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueCertificatePayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Certificate

	if len(errors) > 0 {
		return IssueCertificatePayloadMultiError(errors)
	}

	return nil
}

// IssueCertificatePayloadMultiError is an error wrapping multiple validation
// errors returned by IssueCertificatePayload.ValidateAll() if the designated
// constraints aren't met.
type IssueCertificatePayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueCertificatePayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueCertificatePayloadMultiError) AllErrors() []error { return m }

// IssueCertificatePayloadValidationError is the validation error returned by
// IssueCertificatePayload.Validate if the designated constraints aren't met.
type IssueCertificatePayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueCertificatePayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueCertificatePayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueCertificatePayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueCertificatePayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueCertificatePayloadValidationError) ErrorName() string {
	return "IssueCertificatePayloadValidationError"
}

// Error satisfies the builtin error interface
func (e IssueCertificatePayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueCertificatePayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueCertificatePayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueCertificatePayloadValidationError{}

// Validate checks the field values on RevokeCertificatePayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevokeCertificatePayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeCertificatePayload with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevokeCertificatePayloadMultiError, or nil if none found.
func (m *RevokeCertificatePayload) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeCertificatePayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Certificate

	// no validation rules for RevokedBy

	if len(errors) > 0 {
		return RevokeCertificatePayloadMultiError(errors)
	}

	return nil
}

// RevokeCertificatePayloadMultiError is an error wrapping multiple validation
// errors returned by RevokeCertificatePayload.ValidateAll() if the designated
// constraints aren't met.
type RevokeCertificatePayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeCertificatePayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeCertificatePayloadMultiError) AllErrors() []error { return m }

// RevokeCertificatePayloadValidationError is the validation error returned by
// RevokeCertificatePayload.Validate if the designated constraints aren't met.
type RevokeCertificatePayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeCertificatePayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeCertificatePayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeCertificatePayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeCertificatePayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeCertificatePayloadValidationError) ErrorName() string {
	return "RevokeCertificatePayloadValidationError"
}

// Error satisfies the builtin error interface
func (e RevokeCertificatePayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeCertificatePayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeCertificatePayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeCertificatePayloadValidationError{}

// Validate checks the field values on IssueSessionCredentialsPayload with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueSessionCredentialsPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueSessionCredentialsPayload with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// IssueSessionCredentialsPayloadMultiError, or nil if none found.
func (m *IssueSessionCredentialsPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueSessionCredentialsPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserCertificate

	// no validation rules for UserSuppliedReason

	// no validation rules for RoleAccessRequestTrillianMerkleHash

	if len(errors) > 0 {
		return IssueSessionCredentialsPayloadMultiError(errors)
	}

	return nil
}

// IssueSessionCredentialsPayloadMultiError is an error wrapping multiple
// validation errors returned by IssueSessionCredentialsPayload.ValidateAll()
// if the designated constraints aren't met.
type IssueSessionCredentialsPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueSessionCredentialsPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueSessionCredentialsPayloadMultiError) AllErrors() []error { return m }

// IssueSessionCredentialsPayloadValidationError is the validation error
// returned by IssueSessionCredentialsPayload.Validate if the designated
// constraints aren't met.
type IssueSessionCredentialsPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueSessionCredentialsPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueSessionCredentialsPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueSessionCredentialsPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueSessionCredentialsPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueSessionCredentialsPayloadValidationError) ErrorName() string {
	return "IssueSessionCredentialsPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e IssueSessionCredentialsPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueSessionCredentialsPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueSessionCredentialsPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueSessionCredentialsPayloadValidationError{}

// Validate checks the field values on OktaAccessWorkflowInitiatedPayload with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *OktaAccessWorkflowInitiatedPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OktaAccessWorkflowInitiatedPayload
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// OktaAccessWorkflowInitiatedPayloadMultiError, or nil if none found.
func (m *OktaAccessWorkflowInitiatedPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *OktaAccessWorkflowInitiatedPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InvocationArn

	// no validation rules for UserCertificate

	// no validation rules for OktaGroup

	// no validation rules for RoleAccessRequestTrillianMerkleHash

	// no validation rules for UserSuppliedReason

	if len(errors) > 0 {
		return OktaAccessWorkflowInitiatedPayloadMultiError(errors)
	}

	return nil
}

// OktaAccessWorkflowInitiatedPayloadMultiError is an error wrapping multiple
// validation errors returned by
// OktaAccessWorkflowInitiatedPayload.ValidateAll() if the designated
// constraints aren't met.
type OktaAccessWorkflowInitiatedPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OktaAccessWorkflowInitiatedPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OktaAccessWorkflowInitiatedPayloadMultiError) AllErrors() []error { return m }

// OktaAccessWorkflowInitiatedPayloadValidationError is the validation error
// returned by OktaAccessWorkflowInitiatedPayload.Validate if the designated
// constraints aren't met.
type OktaAccessWorkflowInitiatedPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OktaAccessWorkflowInitiatedPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OktaAccessWorkflowInitiatedPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OktaAccessWorkflowInitiatedPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OktaAccessWorkflowInitiatedPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OktaAccessWorkflowInitiatedPayloadValidationError) ErrorName() string {
	return "OktaAccessWorkflowInitiatedPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e OktaAccessWorkflowInitiatedPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOktaAccessWorkflowInitiatedPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OktaAccessWorkflowInitiatedPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OktaAccessWorkflowInitiatedPayloadValidationError{}

// Validate checks the field values on Envelope with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Envelope) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Envelope with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnvelopeMultiError, or nil
// if none found.
func (m *Envelope) ValidateAll() error {
	return m.validate(true)
}

func (m *Envelope) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnvelopeValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnvelopeValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnvelopeValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetSignature()) > 256 {
		err := EnvelopeValidationError{
			field:  "Signature",
			reason: "value length must be at most 256 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EnvelopeMultiError(errors)
	}

	return nil
}

// EnvelopeMultiError is an error wrapping multiple validation errors returned
// by Envelope.ValidateAll() if the designated constraints aren't met.
type EnvelopeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvelopeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvelopeMultiError) AllErrors() []error { return m }

// EnvelopeValidationError is the validation error returned by
// Envelope.Validate if the designated constraints aren't met.
type EnvelopeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvelopeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvelopeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvelopeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvelopeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvelopeValidationError) ErrorName() string { return "EnvelopeValidationError" }

// Error satisfies the builtin error interface
func (e EnvelopeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvelope.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvelopeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvelopeValidationError{}

// Validate checks the field values on Payload with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Payload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Payload with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PayloadMultiError, or nil if none found.
func (m *Payload) ValidateAll() error {
	return m.validate(true)
}

func (m *Payload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayloadValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayloadValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayloadValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.Contents.(type) {

	case *Payload_ApproveConfig:

		if all {
			switch v := interface{}(m.GetApproveConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "ApproveConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "ApproveConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApproveConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadValidationError{
					field:  "ApproveConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Payload_IssueCertificate:

		if all {
			switch v := interface{}(m.GetIssueCertificate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "IssueCertificate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "IssueCertificate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIssueCertificate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadValidationError{
					field:  "IssueCertificate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Payload_RevokeCertificate:

		if all {
			switch v := interface{}(m.GetRevokeCertificate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "RevokeCertificate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "RevokeCertificate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRevokeCertificate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadValidationError{
					field:  "RevokeCertificate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Payload_IssueSessionCredentials:

		if all {
			switch v := interface{}(m.GetIssueSessionCredentials()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "IssueSessionCredentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "IssueSessionCredentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIssueSessionCredentials()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadValidationError{
					field:  "IssueSessionCredentials",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Payload_RoleAccessRequest:

		if all {
			switch v := interface{}(m.GetRoleAccessRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "RoleAccessRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "RoleAccessRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRoleAccessRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadValidationError{
					field:  "RoleAccessRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Payload_ApprovedRoleAccessRequest:

		if all {
			switch v := interface{}(m.GetApprovedRoleAccessRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "ApprovedRoleAccessRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "ApprovedRoleAccessRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApprovedRoleAccessRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadValidationError{
					field:  "ApprovedRoleAccessRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Payload_DeclinedRoleAccessRequest:

		if all {
			switch v := interface{}(m.GetDeclinedRoleAccessRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "DeclinedRoleAccessRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "DeclinedRoleAccessRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeclinedRoleAccessRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadValidationError{
					field:  "DeclinedRoleAccessRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Payload_CancelledRoleAccessRequest:

		if all {
			switch v := interface{}(m.GetCancelledRoleAccessRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "CancelledRoleAccessRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "CancelledRoleAccessRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCancelledRoleAccessRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadValidationError{
					field:  "CancelledRoleAccessRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Payload_OktaAccessWorkflowInitiated:

		if all {
			switch v := interface{}(m.GetOktaAccessWorkflowInitiated()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "OktaAccessWorkflowInitiated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadValidationError{
						field:  "OktaAccessWorkflowInitiated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOktaAccessWorkflowInitiated()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadValidationError{
					field:  "OktaAccessWorkflowInitiated",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PayloadMultiError(errors)
	}

	return nil
}

// PayloadMultiError is an error wrapping multiple validation errors returned
// by Payload.ValidateAll() if the designated constraints aren't met.
type PayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayloadMultiError) AllErrors() []error { return m }

// PayloadValidationError is the validation error returned by Payload.Validate
// if the designated constraints aren't met.
type PayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayloadValidationError) ErrorName() string { return "PayloadValidationError" }

// Error satisfies the builtin error interface
func (e PayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayloadValidationError{}

// Validate checks the field values on StoreRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StoreRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StoreRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StoreRequestMultiError, or
// nil if none found.
func (m *StoreRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StoreRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEnvelope()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StoreRequestValidationError{
					field:  "Envelope",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StoreRequestValidationError{
					field:  "Envelope",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnvelope()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StoreRequestValidationError{
				field:  "Envelope",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StoreRequestMultiError(errors)
	}

	return nil
}

// StoreRequestMultiError is an error wrapping multiple validation errors
// returned by StoreRequest.ValidateAll() if the designated constraints aren't met.
type StoreRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StoreRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StoreRequestMultiError) AllErrors() []error { return m }

// StoreRequestValidationError is the validation error returned by
// StoreRequest.Validate if the designated constraints aren't met.
type StoreRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StoreRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StoreRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StoreRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StoreRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StoreRequestValidationError) ErrorName() string { return "StoreRequestValidationError" }

// Error satisfies the builtin error interface
func (e StoreRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStoreRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StoreRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StoreRequestValidationError{}

// Validate checks the field values on StoreResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StoreResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StoreResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StoreResponseMultiError, or
// nil if none found.
func (m *StoreResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StoreResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Contents.(type) {

	case *StoreResponse_RoleAccessRequestId:
		// no validation rules for RoleAccessRequestId

	}

	if len(errors) > 0 {
		return StoreResponseMultiError(errors)
	}

	return nil
}

// StoreResponseMultiError is an error wrapping multiple validation errors
// returned by StoreResponse.ValidateAll() if the designated constraints
// aren't met.
type StoreResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StoreResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StoreResponseMultiError) AllErrors() []error { return m }

// StoreResponseValidationError is the validation error returned by
// StoreResponse.Validate if the designated constraints aren't met.
type StoreResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StoreResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StoreResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StoreResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StoreResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StoreResponseValidationError) ErrorName() string { return "StoreResponseValidationError" }

// Error satisfies the builtin error interface
func (e StoreResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStoreResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StoreResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StoreResponseValidationError{}

// Validate checks the field values on GetEntriesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetEntriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEntriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetEntriesRequestMultiError, or nil if none found.
func (m *GetEntriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEntriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StartIndex

	// no validation rules for Count

	if len(errors) > 0 {
		return GetEntriesRequestMultiError(errors)
	}

	return nil
}

// GetEntriesRequestMultiError is an error wrapping multiple validation errors
// returned by GetEntriesRequest.ValidateAll() if the designated constraints
// aren't met.
type GetEntriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEntriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEntriesRequestMultiError) AllErrors() []error { return m }

// GetEntriesRequestValidationError is the validation error returned by
// GetEntriesRequest.Validate if the designated constraints aren't met.
type GetEntriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEntriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEntriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEntriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEntriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEntriesRequestValidationError) ErrorName() string {
	return "GetEntriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetEntriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEntriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEntriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEntriesRequestValidationError{}

// Validate checks the field values on GetEntriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetEntriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEntriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetEntriesResponseMultiError, or nil if none found.
func (m *GetEntriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEntriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEnvelopes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetEntriesResponseValidationError{
						field:  fmt.Sprintf("Envelopes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetEntriesResponseValidationError{
						field:  fmt.Sprintf("Envelopes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetEntriesResponseValidationError{
					field:  fmt.Sprintf("Envelopes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetEntriesResponseMultiError(errors)
	}

	return nil
}

// GetEntriesResponseMultiError is an error wrapping multiple validation errors
// returned by GetEntriesResponse.ValidateAll() if the designated constraints
// aren't met.
type GetEntriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEntriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEntriesResponseMultiError) AllErrors() []error { return m }

// GetEntriesResponseValidationError is the validation error returned by
// GetEntriesResponse.Validate if the designated constraints aren't met.
type GetEntriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEntriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEntriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEntriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEntriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEntriesResponseValidationError) ErrorName() string {
	return "GetEntriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetEntriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEntriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEntriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEntriesResponseValidationError{}

// Validate checks the field values on IncludedEnvelope with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IncludedEnvelope) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IncludedEnvelope with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IncludedEnvelopeMultiError, or nil if none found.
func (m *IncludedEnvelope) ValidateAll() error {
	return m.validate(true)
}

func (m *IncludedEnvelope) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEnvelope()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncludedEnvelopeValidationError{
					field:  "Envelope",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncludedEnvelopeValidationError{
					field:  "Envelope",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnvelope()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncludedEnvelopeValidationError{
				field:  "Envelope",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TrillianMerkleHash

	if len(errors) > 0 {
		return IncludedEnvelopeMultiError(errors)
	}

	return nil
}

// IncludedEnvelopeMultiError is an error wrapping multiple validation errors
// returned by IncludedEnvelope.ValidateAll() if the designated constraints
// aren't met.
type IncludedEnvelopeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IncludedEnvelopeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IncludedEnvelopeMultiError) AllErrors() []error { return m }

// IncludedEnvelopeValidationError is the validation error returned by
// IncludedEnvelope.Validate if the designated constraints aren't met.
type IncludedEnvelopeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IncludedEnvelopeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IncludedEnvelopeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IncludedEnvelopeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IncludedEnvelopeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IncludedEnvelopeValidationError) ErrorName() string { return "IncludedEnvelopeValidationError" }

// Error satisfies the builtin error interface
func (e IncludedEnvelopeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIncludedEnvelope.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IncludedEnvelopeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IncludedEnvelopeValidationError{}

// Validate checks the field values on GetLatestSignedLogRootRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLatestSignedLogRootRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLatestSignedLogRootRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetLatestSignedLogRootRequestMultiError, or nil if none found.
func (m *GetLatestSignedLogRootRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLatestSignedLogRootRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetLatestSignedLogRootRequestMultiError(errors)
	}

	return nil
}

// GetLatestSignedLogRootRequestMultiError is an error wrapping multiple
// validation errors returned by GetLatestSignedLogRootRequest.ValidateAll()
// if the designated constraints aren't met.
type GetLatestSignedLogRootRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLatestSignedLogRootRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLatestSignedLogRootRequestMultiError) AllErrors() []error { return m }

// GetLatestSignedLogRootRequestValidationError is the validation error
// returned by GetLatestSignedLogRootRequest.Validate if the designated
// constraints aren't met.
type GetLatestSignedLogRootRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLatestSignedLogRootRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLatestSignedLogRootRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLatestSignedLogRootRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLatestSignedLogRootRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLatestSignedLogRootRequestValidationError) ErrorName() string {
	return "GetLatestSignedLogRootRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLatestSignedLogRootRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLatestSignedLogRootRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLatestSignedLogRootRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLatestSignedLogRootRequestValidationError{}

// Validate checks the field values on GetLatestSignedLogRootResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLatestSignedLogRootResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLatestSignedLogRootResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetLatestSignedLogRootResponseMultiError, or nil if none found.
func (m *GetLatestSignedLogRootResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLatestSignedLogRootResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogRoot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLatestSignedLogRootResponseValidationError{
					field:  "LogRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLatestSignedLogRootResponseValidationError{
					field:  "LogRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogRoot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLatestSignedLogRootResponseValidationError{
				field:  "LogRoot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetLatestSignedLogRootResponseMultiError(errors)
	}

	return nil
}

// GetLatestSignedLogRootResponseMultiError is an error wrapping multiple
// validation errors returned by GetLatestSignedLogRootResponse.ValidateAll()
// if the designated constraints aren't met.
type GetLatestSignedLogRootResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLatestSignedLogRootResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLatestSignedLogRootResponseMultiError) AllErrors() []error { return m }

// GetLatestSignedLogRootResponseValidationError is the validation error
// returned by GetLatestSignedLogRootResponse.Validate if the designated
// constraints aren't met.
type GetLatestSignedLogRootResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLatestSignedLogRootResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLatestSignedLogRootResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLatestSignedLogRootResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLatestSignedLogRootResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLatestSignedLogRootResponseValidationError) ErrorName() string {
	return "GetLatestSignedLogRootResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetLatestSignedLogRootResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLatestSignedLogRootResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLatestSignedLogRootResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLatestSignedLogRootResponseValidationError{}

// Validate checks the field values on LogRoot with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogRoot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogRoot with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LogRootMultiError, or nil if none found.
func (m *LogRoot) ValidateAll() error {
	return m.validate(true)
}

func (m *LogRoot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TreeSize

	// no validation rules for RootHash

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogRootValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogRootValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogRootValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogRootMultiError(errors)
	}

	return nil
}

// LogRootMultiError is an error wrapping multiple validation errors returned
// by LogRoot.ValidateAll() if the designated constraints aren't met.
type LogRootMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogRootMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogRootMultiError) AllErrors() []error { return m }

// LogRootValidationError is the validation error returned by LogRoot.Validate
// if the designated constraints aren't met.
type LogRootValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogRootValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogRootValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogRootValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogRootValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogRootValidationError) ErrorName() string { return "LogRootValidationError" }

// Error satisfies the builtin error interface
func (e LogRootValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogRoot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogRootValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogRootValidationError{}
